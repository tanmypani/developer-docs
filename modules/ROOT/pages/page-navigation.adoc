= Build navigation to ThoughtSpot content
:toc: true

:page-title: Build navigation to ThoughtSpot content
:page-pageid: in-app-navigation
:page-description: Build navigation to ThoughtSpot content from the embedding application

The embedding application can retrieve the available content for a ThoughtSpot user via REST API, then render the response as menu items or buttons that link to or load ThoughtSpot embedded components.

All REST API requests from the browser are scoped to the signed-in user and show only those objects that a user can access.

If you are using the ThoughtSpot xref:full-embed.adoc[AppEmbed component] to embed the full ThoughtSpot application, please see the documentation for xref:full-app-customize.adoc[customizing navigation within the full app embed].

== Create web app URLs for embedded ThoughtSpot pages
Modern web applications have various architectures for how URLs are translated into the actual content delivered to the user's web browser. 

=== ThoughtSpot object types and object ids
Every object in ThoughtSpot is referenced by a globally unique identifier (GUID), which appears as the `id:` or `guid:` property in API responses and TML files.

Visual Embed SDK components require object IDs to load the correct content.

The object ID is part of the URLs to load objects in ThoughtSpot. For example, the GUID of the Liveboard appears at the end of the URL:

`{your-domain}.thoughtspot.cloud/#/pinboard/*ddd982ea-c7bc-4c00-9b49-c53fab949b34*`

=== Web app URL patterns
Within the embedding web app, create one or more URL patterns that include variables for: 

* A reference to the ThoughtSpot *object type* (does not have to match ThoughtSpot names for the object types)
* The ThoughtSpot *object ID(s)*

These two details are necesssary to load the correct ThoughtSpot embed component with the desired ThoughtSpot object.

Example URL patterns for various component types:

xref:embed-pinboard.adoc[LiveboardEmbed] component for a Liveboard: 

`{web-app-name}.{your-domain}.com/analytics/dashboard/*{liveboardId}*`

xref:embed-pinboard.adoc[LiveboardEmbed] component for a Viz on a Liveboard: 

`{web-app-name}.{your-domain}.com/analytics/dashboard/*{liveboardId}*/*{vizId}*`

xref:embed-a-viz.adoc[SearchEmbed] component to a datasource: 

`{web-app-name}.{your-domain}.com/analytics/data/*{datasourceId}*`

xref:embed-search.adoc[SearchEmbed] component to an existing Answer: 

`{web-app-name}.{your-domain}.com/analytics/report/*{answerId}*`

With defined URL patterns, you can xref:customize-links.adoc[customize links] within ThoughtSpot so that e-mails and other exported references send users to the embedding web app's pages rather than directly to the ThoughtSpot instance.

== Create menus to embedded ThoughtSpot pages
Once you have the URL patterns defined within the embedding application to load ThoughtSpot content, you can build out the navigation elements to reach the content a given user has access to.

Navigation typically takes the form of elements in a menu, but could also be a dropdown selector or a set of buttons.

=== "Hardcoded" links within a menu system
If your web application only embeds a limited set of ThoughtSpot objects, without granting users the ability to save their own objects, you can "hardcode" the object IDs and names of the ThoughtSpot content.

Object IDs in ThoughtSpot are GUIDs and thus are unique on every org or instance, with the exception of separate instances that are intentionally replicated with the same GUIDs via TML import and export.

You may still use the `xref:rest-api-v2-metadata-search.adoc[/metadata/search]` V2.0 REST API endpoint to retrieve the equivalent object IDs for content on various orgs and environments in the process of "hardcoding" the menu system. Alternatively you may keep a *mapping file* of equivalent objects during your CICD deployment process, that you use to generate the "hardcoded URLs" in the menu system.

=== Dynamic requests for content listings via REST API
Both the V1 and V2.0 REST APIs have endpoints for retrieving filtered lists of the content a user has access to. The `xref:rest-api-v2-metadata-search.adoc[/metadata/search]` V2.0 REST API endpoint is the simpler of the APIs to use from the user's web browser, while the xref:metadata-api.adoc#metadata-list[metadata/list V1 REST API endpoint] is identical to the endpoint used within ThoughtSpot to rendering the Answers, Liveboards, and Data pages.

The process for generating a dynamic menu is:

1. Ensure the system can request content as a user (sign-in with browser or an access token) 
2. Request the user's available content via the REST API
3. (Optional) Cache the results within embedding application
4. Render the menu items within the web application, with links to ThoughtSpot pages within the web app

==== Requesting content as a user

==== /metadata/list V1 REST API
The endpoint can only request one object type at a time: +

* `PINBOARD_ANSWER_BOOK` for Liveboards
* `QUESTION_ANSWER_BOOK` for answers
* `LOGICAL_TABLE` for data objects

Data objects can be filtered using an additional `subtype` parameter to limit the query specifically to ThoughtSpot tables, worksheets, or views.

There are additional parameters for sorting and a `category` parameter that can filter the response to show only the objects created or marked as favorites by the logged-in user.

REST API calls are asynchronous. The following is an example function returning the response as a JSON object using *fetch()*:

[source,javascript]
----
    async function metadataListRestApiCall(args){
        // args = { 'type', 'category', 'sortOn', 'sortAsc', 'tagnames' }
        let type = args['type'].toLowerCase();
        const publicApiUrl = 'callosum/v1/tspublic/v1/';
        let endpoint = 'metadata/list';

        // Easy type names match ThoughtSpot UI names for objects
        const typesToApiType = {
            'liveboard': 'PINBOARD_ANSWER_BOOK',
            'answer': 'QUESTION_ANSWER_BOOK',
            'datasource' : 'LOGICAL_TABLE', // datasource doesn't distinguish sub-types
            'table' : 'ONE_TO_ONE_LOGICAL',
            'view' : 'AGGR_WORKSHEET',
            'worksheet' : 'WORKSHEET'
        }

        // batchsize = -1 gives all results
        let apiParams = { 'batchsize' : '-1'};
        console.log(type);
        // The three datasource types can be specified using 'subtype'
        if (type == 'table' || type == 'view' || type == 'worksheet'){
            let subtype = [typesToApiType[type]];
            apiParams['type'] = 'LOGICAL_TABLE';
            apiParams['subtypes'] = `["${subtype}"]`;
        }
        else {
            apiParams['type'] = typesToApiType[type];
        }

        // Category arguments
        let category = 'ALL';
        if ('category' in args){
            if ( args['category'] == 'MY' || args['category'] == 'ALL' || args['category'] == 'FAVORITE'){
                category = args['category'];
                apiParams['category'] = category;
            }
        }

        // Sort arguments
        if ('sortOn' in args){
            if (args['sortOn'] !== null){
                apiParams['sort'] = args['sortOn'];
            }
        }

        if ('sortAsc' in args){
            if (args['sortAsc'] === true){
                apiParams['sortascending'] = 'true';
            }
            if (args['sortAsc'] === false){
                apiParams['sortascending'] = 'false';
            }
        }

        console.log(apiParams);
        const searchParams = new URLSearchParams(apiParams);
        const apiFullEndpoint = tsURL + publicApiUrl + endpoint + "?" + searchParams.toString();
        console.log(apiFullEndpoint);
        return await fetch(
            apiFullEndpoint, {
            method: 'GET',
            headers: {
                "Accept": "application/json",
                "X-Requested-By": "ThoughtSpot"
            },
            credentials: "include"
            })
        .then(response =>  response.json())
        .then(data => data['headers'])  // metadata/list info is really in the 'headers' property returned
        .catch(error => {
        console.error("Unable to get the metadata/list response: " + error)
        });
    }
----

The results of this REST API request can be directed into a rendering function using `.then()`:

[source,javascript]
----
metadataListRestApiCall(
    {
        'type': 'liveboard',
        'sortOn': 'NAME',
        'sortAsc' : true,
        'category': 'ALL'
    })
.then(
    (listResponse) => renderNavigationFromResponse(listResponse) // Use your own rendering function here
);
----

=== Render navigation elements
The response from the function in the preceding example is an array of header objects, which can be parsed to render navigation.

The `name` and `id` property are used in almost all the navigation you build (`id` is the GUID necessary to load any ThoughtSpot object). Additional properties include:

* `description`
+
Text description added to content by creator
* `authorDisplayName`
+
Display name of the object creator or current owner
* `authorName`
+
Username of the object creator or current owner
* `created`
+
Object creation timestamp (to milliseconds)
* `modified`
+
Last edit timestamp (to milliseconds)
* `tags`
+
Array of tag objects, each with a `name` property among other details

=== Replicate ThoughtSpot application listing pages
If you want to render something very close to the 'Answers' or 'Liveboards' pages within the ThoughtSpot UI, your rendering function will grab the `name`, `id`, `tags`, `modified` and `authorDisplayName` properties and make a table in that order (feel free to leave out any undesired elements):

[source,javascript]
----
    function tableFromList(listResponse){
        console.log(listResponse);
        let t = document.createElement('table');

        // Make table headers
        let thead = document.createElement('thead');
        t.append(thead);
        let thr = document.createElement('tr');
        thead.append(thr);
        let headers = ['Name', 'Tags', 'Modified', 'Author'];
        for (let i=0, len=headers.length; i < len; i++){
            let th = document.createElement('th');
            th.innerText = headers[i];
            thr.append(th);
        }

        // Go through response and build rows
        for (let i=0, len=listResponse.length; i < len; i++){
            let tr = document.createElement('tr');

            // Name Column
            let name_td = document.createElement('td');
            name_td.innerHTML = '<a href="#" onclick="loadContent("' + listResponse[i]['id'] + '")>' +  listResponse[i]['name'] +  '</a>';
            //name_td.append(name_text);
            console.log(name_td);
            tr.append(name_td);

            // Tags column
            let tags_td = document.createElement('td');
            console.log(listResponse[i]['tags']);
            // Tags is an Array of Tag objects, with properties ('name' being the important one)
            if (listResponse[i]['tags'].length > 0){
                let tagNames = [];
                for(let k = 0, len = listResponse[i]['tags'].length; k<len; k++){
                    let tagName = listResponse[i]['tags'][k]['name'];
                    tagNames.push(tagName);
                }
                tags_td.innerText = tagNames.join(', ');
            }
            tr.append(tags_td);

            // Modified Date column
            let modified_td = document.createElement('td');
            modified_td.innerText = listResponse[i]['modified'];
            tr.append(modified_td);

            let author_td = document.createElement('td');
            author_td.innerText = listResponse[i]['authorDisplayName'];
            tr.append(author_td);

            t.append(tr);

        }

        return t;
    }
----

The function in the preceding example merely creates the table, it does not place it on the page. You can continue chaining using `.then()` to place the table in the appropriate place on your web application page :

[source,javascript]
----
metadataListRestApiCall(
    {
        'type': 'liveboard',
        'sortOn': 'NAME',
        'sortAsc' : true,
        'category': 'ALL'
    })
.then(
    (response) => tableFromList(response)
).then(
    (table) => document.getElementById('main-content-div').append(table)
);
----

Note that the `loadContent()` function referenced in the anchor tag created for the name column in the function above is a placeholder representing whatever is necessary to load that type of ThoughtSpot content in the web application. The actual design you choose for your application will determine the code you need to go from the navigation component to loading the ThoughtSpot content.

=== Retrieve individual visualizations from a Liveboard
You can load individual visualizations on a Liveboard using the `LiveboardEmbed` component by supplying both `liveboardId` and `vizId`.

The display of a visualization from a Liveboard differs from a saved Answer object, which is loaded via the `SearchEmbed` component. The saved answer object always displays the ThoughtSpot search bar and UI actions for editing an Answer, whereas the visualizations display fewer UI elements and show the menu items in the **More** menu image:./images/icon-more-10px.png[the more options menu].

To retrieve a list of visualizations from a Liveboard, you can use the xref:metadata-api.adoc#viz-header[get visualization headers REST API endpoint].

[source,javascript]
----
async function metadataGetVizHeadersRestApiCall(liveboardGuid){
    // args = { 'type', 'category', 'sortOn', 'sortAsc', 'tagnames' }
    let type = args['type'].toLowerCase();
    const publicApiUrl = 'callosum/v1/tspublic/v1/';
    let endpoint = 'metadata/listvizheaders';

    // batchsize = -1 gives all results
    let apiParams = { 'id' : liveboardGuid};
    const searchParams = new URLSearchParams(apiParams);
    const apiFullEndpoint = tsURL + publicApiUrl + endpoint + "?" + searchParams.toString();
    console.log(apiFullEndpoint);
    return await fetch(
        apiFullEndpoint, {
        method: 'GET',
        headers: {
            "Accept": "application/json",
            "X-Requested-By": "ThoughtSpot"
        },
        credentials: "include"
        })
    .then(response =>  response.json())
    //
    .then(data => data)  // metadata/list info is really in the 'headers' property returned
    .catch(error => {
    console.error("Unable to get the metadata/listvizheaders response: " + error)
    });
}
----
