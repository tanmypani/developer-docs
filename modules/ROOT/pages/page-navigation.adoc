= Build navigation to ThoughtSpot content
:toc: true

:page-title: Build navigation to ThoughtSpot content
:page-pageid: in-app-navigation
:page-description: Build navigation to ThoughtSpot content from the embedding application

This documentation page covers two related aspects of integrating ThoughtSpot content into another application:

* Creating URLs that load various ThoughtSpot objects correctly within the embedding app
* Retrieving ThoughtSpot objects available to a given web application user

The embedding application can retrieve the available content for a ThoughtSpot user via REST API, then render the response as menu items or buttons that link to the URLs within the web app that load the proper ThoughtSpot embedded component with the desired object ID.

If you are using the ThoughtSpot xref:full-embed.adoc[AppEmbed component] to embed any of the pages from the full ThoughtSpot application, please see the documentation for xref:full-app-customize.adoc[customizing navigation within the full app embed].

== Create web app URLs for embedded ThoughtSpot pages
Modern web applications have various architectures for how URLs are translated into the actual content delivered to the user's web browser.

The ThoughtSpot Visual Embed SDK uses different components depending on the object type to be loaded, so the URL must include a reference to both the ThoughtSpot object type and the object ID to load it properly. 

=== ThoughtSpot object types and object ids
Every object in ThoughtSpot is referenced by a globally unique identifier (GUID), which appears as the `id:` or `guid:` property in API responses and TML files.

Visual Embed SDK components require object IDs to load the correct content.

The object ID is part of the URLs to load objects in ThoughtSpot. For example, the GUID of the Liveboard appears at the end of the URL:

`{your-domain}.thoughtspot.cloud/#/pinboard/*ddd982ea-c7bc-4c00-9b49-c53fab949b34*`

When hardcoding ThoughtSpot object IDs, you can use the ThoughtSpot application URL or Visual Embed SDK playground to find the object IDs. Most developers switch to using the REST APIs to retrieve the object IDs as their integration project progresses (see below).

=== Web app URL patterns
Within the embedding web app, create one or more URL patterns that include variables for: 

* A reference to the ThoughtSpot *object type* (does not have to match ThoughtSpot names for the object types)
* The ThoughtSpot *object ID(s)*

These two details are necesssary to load the correct ThoughtSpot embed component with the desired ThoughtSpot object.

Example URL patterns for various component types:

xref:embed-pinboard.adoc[LiveboardEmbed] component for a Liveboard: 

`{web-app-name}.{your-domain}.com/analytics/dashboard/*{liveboardId}*`

xref:embed-pinboard.adoc[LiveboardEmbed] component for a specific Viz on a Liveboard: 

`{web-app-name}.{your-domain}.com/analytics/dashboard/*{liveboardId}*/*{vizId}*`

xref:embed-a-viz.adoc[SearchEmbed] component to a datasource: 

`{web-app-name}.{your-domain}.com/analytics/data/*{datasourceId}*`

xref:embed-search.adoc[SearchEmbed] component to an existing Answer: 

`{web-app-name}.{your-domain}.com/analytics/report/*{answerId}*`

With defined URL patterns, you can xref:customize-links.adoc[customize links] within ThoughtSpot so that e-mails and other exported references send users to the embedding web app's pages rather than directly to the ThoughtSpot instance.

== Create menus to embedded ThoughtSpot pages
Once you have the URL patterns defined within the embedding application to load ThoughtSpot content, you can build out the navigation elements to reach the content a given user has access to.

Navigation typically takes the form of elements in a menu, but could also be a dropdown selector or a set of buttons.

=== "Hardcoded" links within a menu system
If your web application only embeds a limited set of ThoughtSpot objects, without granting users the ability to save their own objects, you can "hardcode" the object IDs and names of the ThoughtSpot content.

Object IDs in ThoughtSpot are GUIDs and thus are unique on every org or instance, with the exception of separate instances that are intentionally replicated with the same GUIDs via TML import and export.

You may still use the `xref:rest-api-v2-metadata-search.adoc[/metadata/search]` V2.0 REST API endpoint to retrieve the equivalent object IDs for content on various orgs and environments in the process of "hardcoding" the menu system. Alternatively you may keep a *mapping file* of equivalent objects during your CICD deployment process, that you use to generate the "hardcoded URLs" in the menu system.

=== Dynamic requests for content listings via REST API
Both the V1 and V2.0 REST APIs have endpoints for retrieving filtered lists of the content a user has access to. 

The xref:rest-api-v2-metadata-search.adoc[/metadata/search V2.0 REST API endpoint] is the simpler of the APIs to use from the user's web browser, while the xref:metadata-api.adoc#metadata-list[/metadata/list V1 REST API endpoint] is identical to the endpoint used within ThoughtSpot to rendering the Answers, Liveboards, and Data pages, making it simple if you desire to replicate and customize the pages within ThoughtSpot.

The process for generating a dynamic menu is:

1. Ensure the system can request content as a user (sign-in with browser or an access token) 
2. Request the user's available content via the REST API
3. (Optional) Cache the results within embedding application
4. Render the menu items within the web application, with links to ThoughtSpot pages within the web app

==== Requesting content as a user


All REST API requests from the browser are scoped as the signed-in user, as long as the `credentials` option of the REST API request has been set properly to `include`.

With xref:trusted-authentication.adoc[cookieless trusted authentication], there is no *browser session* but instead an *access token* is retrieved for the user and used by the SDK. The same access token for authentication can be used to make REST API requests, or a second access token can be generated for use with REST API requests.

The trusted authentication pattern requires implementing a backend service to generate access tokens for any user. The token request service can instead be used by the back-end of the embedding web application to get an access token to make REST API requests for a user, rather than having it happen at the front-end within the web browser. 

If implementing a caching system for the ThoughtSpot content listings, implementing on the back-end may be preferred.

==== /metadata/list V1 REST API
The endpoint can only request one object type at a time: +

* `PINBOARD_ANSWER_BOOK` for Liveboards
* `QUESTION_ANSWER_BOOK` for answers
* `LOGICAL_TABLE` for data objects

Data objects can be filtered using an additional `subtype` parameter to limit the query specifically to ThoughtSpot tables, worksheets, or views.

There are additional parameters for sorting and a `category` parameter that can filter the response to show only the objects created or marked as favorites by the logged-in user.

REST API calls are asynchronous. The following is an example function returning the response as a JSON object using *fetch()*:

[source,javascript]
----
    async function metadataListRestApiCall(args){
        // args = { 'type', 'category', 'sortOn', 'sortAsc', 'tagnames' }
        let type = args['type'].toLowerCase();
        const publicApiUrl = 'callosum/v1/tspublic/v1/';
        let endpoint = 'metadata/list';

        // Easy type names match ThoughtSpot UI names for objects
        const typesToApiType = {
            'liveboard': 'PINBOARD_ANSWER_BOOK',
            'answer': 'QUESTION_ANSWER_BOOK',
            'datasource' : 'LOGICAL_TABLE', // datasource doesn't distinguish sub-types
            'table' : 'ONE_TO_ONE_LOGICAL',
            'view' : 'AGGR_WORKSHEET',
            'worksheet' : 'WORKSHEET'
        }

        // batchsize = -1 gives all results
        let apiParams = { 'batchsize' : '-1'};
        console.log(type);
        // The three datasource types can be specified using 'subtype'
        if (type == 'table' || type == 'view' || type == 'worksheet'){
            let subtype = [typesToApiType[type]];
            apiParams['type'] = 'LOGICAL_TABLE';
            apiParams['subtypes'] = `["${subtype}"]`;
        }
        else {
            apiParams['type'] = typesToApiType[type];
        }

        // Category arguments
        let category = 'ALL';
        if ('category' in args){
            if ( args['category'] == 'MY' || args['category'] == 'ALL' || args['category'] == 'FAVORITE'){
                category = args['category'];
                apiParams['category'] = category;
            }
        }

        // Sort arguments
        if ('sortOn' in args){
            if (args['sortOn'] !== null){
                apiParams['sort'] = args['sortOn'];
            }
        }

        if ('sortAsc' in args){
            if (args['sortAsc'] === true){
                apiParams['sortascending'] = 'true';
            }
            if (args['sortAsc'] === false){
                apiParams['sortascending'] = 'false';
            }
        }

        console.log(apiParams);
        const searchParams = new URLSearchParams(apiParams);
        const apiFullEndpoint = tsURL + publicApiUrl + endpoint + "?" + searchParams.toString();
        console.log(apiFullEndpoint);
        return await fetch(
            apiFullEndpoint, {
            method: 'GET',
            headers: {
                "Accept": "application/json",
                "X-Requested-By": "ThoughtSpot"
            },
            credentials: "include"
            })
        .then(response =>  response.json())
        .then(data => data['headers'])  // metadata/list info is really in the 'headers' property returned
        .catch(error => {
        console.error("Unable to get the metadata/list response: " + error)
        });
    }
----

The results of this REST API request can be directed into a rendering function using `.then()`:

[source,javascript]
----
metadataListRestApiCall(
    {
        'type': 'liveboard',
        'sortOn': 'NAME',
        'sortAsc' : true,
        'category': 'ALL'
    })
.then(
    (listResponse) => renderNavigationFromResponse(listResponse) // Use your own rendering function here
);
----

=== Render navigation elements
The response from the function in the preceding example is an array of header objects, which can be parsed to render navigation.

The `name` and `id` property are used in almost all the navigation you build (`id` is the GUID necessary to load any ThoughtSpot object). Additional properties include:

* `description`
+
Text description added to content by creator
* `authorDisplayName`
+
Display name of the object creator or current owner
* `authorName`
+
Username of the object creator or current owner
* `created`
+
Object creation timestamp (to milliseconds)
* `modified`
+
Last edit timestamp (to milliseconds)
* `tags`
+
Array of tag objects, each with a `name` property among other details

=== Replicate ThoughtSpot application listing pages
If you want to render something very close to the 'Answers' or 'Liveboards' pages within the ThoughtSpot UI, your rendering function will grab the `name`, `id`, `tags`, `modified` and `authorDisplayName` properties and make a table in that order (feel free to leave out any undesired elements):

[source,javascript]
----
    function tableFromList(listResponse){
        console.log(listResponse);
        let t = document.createElement('table');

        // Make table headers
        let thead = document.createElement('thead');
        t.append(thead);
        let thr = document.createElement('tr');
        thead.append(thr);
        let headers = ['Name', 'Tags', 'Modified', 'Author'];
        for (let i=0, len=headers.length; i < len; i++){
            let th = document.createElement('th');
            th.innerText = headers[i];
            thr.append(th);
        }

        // Go through response and build rows
        for (let i=0, len=listResponse.length; i < len; i++){
            let tr = document.createElement('tr');

            // Name Column
            let name_td = document.createElement('td');
            name_td.innerHTML = '<a href="#" onclick="loadContent("' + listResponse[i]['id'] + '")>' +  listResponse[i]['name'] +  '</a>';
            //name_td.append(name_text);
            console.log(name_td);
            tr.append(name_td);

            // Tags column
            let tags_td = document.createElement('td');
            console.log(listResponse[i]['tags']);
            // Tags is an Array of Tag objects, with properties ('name' being the important one)
            if (listResponse[i]['tags'].length > 0){
                let tagNames = [];
                for(let k = 0, len = listResponse[i]['tags'].length; k<len; k++){
                    let tagName = listResponse[i]['tags'][k]['name'];
                    tagNames.push(tagName);
                }
                tags_td.innerText = tagNames.join(', ');
            }
            tr.append(tags_td);

            // Modified Date column
            let modified_td = document.createElement('td');
            modified_td.innerText = listResponse[i]['modified'];
            tr.append(modified_td);

            let author_td = document.createElement('td');
            author_td.innerText = listResponse[i]['authorDisplayName'];
            tr.append(author_td);

            t.append(tr);

        }

        return t;
    }
----

The function in the preceding example merely creates the table, it does not place it on the page. You can continue chaining using `.then()` to place the table in the appropriate place on your web application page :

[source,javascript]
----
metadataListRestApiCall(
    {
        'type': 'liveboard',
        'sortOn': 'NAME',
        'sortAsc' : true,
        'category': 'ALL'
    })
.then(
    (response) => tableFromList(response)
).then(
    (table) => document.getElementById('main-content-div').append(table)
);
----

Note that the `loadContent()` function referenced in the anchor tag created for the name column in the function above is a placeholder representing whatever is necessary to load that type of ThoughtSpot content in the web application. The actual design you choose for your application will determine the code you need to go from the navigation component to loading the ThoughtSpot content.

=== Retrieve individual visualizations from a Liveboard
You can load individual visualizations on a Liveboard using the `LiveboardEmbed` component by supplying both `liveboardId` and `vizId`.

The display of a visualization from a Liveboard differs from a saved Answer object, which is loaded via the `SearchEmbed` component. The saved answer object always displays the ThoughtSpot search bar and UI actions for editing an Answer, whereas the visualizations display fewer UI elements and show the menu items in the **More** menu image:./images/icon-more-10px.png[the more options menu].

To retrieve a list of visualizations from a Liveboard, you can use the xref:metadata-api.adoc#viz-header[get visualization headers REST API endpoint].

[source,javascript]
----
async function metadataGetVizHeadersRestApiCall(liveboardGuid){
    // args = { 'type', 'category', 'sortOn', 'sortAsc', 'tagnames' }
    let type = args['type'].toLowerCase();
    const publicApiUrl = 'callosum/v1/tspublic/v1/';
    let endpoint = 'metadata/listvizheaders';

    // batchsize = -1 gives all results
    let apiParams = { 'id' : liveboardGuid};
    const searchParams = new URLSearchParams(apiParams);
    const apiFullEndpoint = tsURL + publicApiUrl + endpoint + "?" + searchParams.toString();
    console.log(apiFullEndpoint);
    return await fetch(
        apiFullEndpoint, {
        method: 'GET',
        headers: {
            "Accept": "application/json",
            "X-Requested-By": "ThoughtSpot"
        },
        credentials: "include"
        })
    .then(response =>  response.json())
    //
    .then(data => data)  // metadata/list info is really in the 'headers' property returned
    .catch(error => {
    console.error("Unable to get the metadata/listvizheaders response: " + error)
    });
}
----
